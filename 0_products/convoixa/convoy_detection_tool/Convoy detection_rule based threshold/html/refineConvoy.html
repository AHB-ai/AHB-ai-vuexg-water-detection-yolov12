
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Refining Convoy Results</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-02-03"><meta name="DC.source" content="refineConvoy.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Refining Convoy Results</h1><!--introduction--><pre>This function is to refine convoy results and reformat to a uniform format.</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">I/O</a></li><li><a href="#2">Code</a></li><li><a href="#6">Navigation</a></li><li><a href="#7">Author</a></li></ul></div><h2>I/O<a name="1"></a></h2><div><ul><li>INPUT:</li></ul></div><p>
<table border=2>
<tr><td><b>pairMap</b></td><td>convoy results stored in a hash map structure.</td></tr>
<tr><td><b>threshold_pair</b></td><td>this is the threshold of convoy session size.</td></tr>
</table>
</p><div><ul><li>OUTPUT:</li></ul></div><p>
<table border=2>
<tr><td><b>convoyMap</b></td><td>refined convoy results saved in a hashmap. </td></tr>
</table>
</p><h2>Code<a name="2"></a></h2><pre class="codeinput"><span class="keyword">function</span> convoyMap =  refineConvoy(pairMap, threshold_pair, anprMap)
</pre><p>Filtering convoy results and organise it into a human-readable format.</p><pre class="codeinput">keySet = keys(pairMap);
convoyMap = containers.Map(<span class="string">'KeyType'</span>,<span class="string">'char'</span>,<span class="string">'ValueType'</span>,<span class="string">'any'</span>);
<span class="keyword">for</span> id=1:length(keySet)
    key_tmp = keySet{id};
    val = pairMap(key_tmp);
    <span class="keyword">if</span> length(val)&gt;threshold_pair
        tmp = strfind(key_tmp, <span class="string">' '</span>);
        carID_cur = key_tmp(1:tmp-1);
        carID_nxt = key_tmp(tmp+1:end);
        test_pair = cell(length(val),3);
        <span class="keyword">for</span> mi=1:length(val)
            time_cur = val{mi}{1};
            test_pair{mi,1} = time_cur;
            test_pair{mi,2} = mi;
        <span class="keyword">end</span>
        test_pair = sortrows(test_pair,1);
        count =1;
        pair_write = cell(length(val),7);
        [tmp_len,~]=size(test_pair);
        <span class="keyword">for</span> im = 1:tmp_len
            idx = test_pair{im,2};
            time_cur = val{idx}{1};
            camID_cur = val{idx}{2};
            make_cur = val{idx}{3};
            model_cur = val{idx}{4};
            color_cur = val{idx}{5};
            tax_cur = val{idx}{6};
            time_nxt = val{idx}{7};
            camID_nxt = val{idx}{8};
            make_nxt = val{idx}{9};
            model_nxt = val{idx}{10};
            color_nxt = val{idx}{11};
            tax_nxt = val{idx}{12};
            number_car_between = val{idx}{13};
            pair_write{count,1} = carID_cur;
            pair_write{count,2} = time_cur;
            pair_write{count,3} = camID_cur;
            pair_write{count,4} = make_cur;
            pair_write{count,5} = model_cur;
            pair_write{count,6} = color_cur;
            pair_write{count,7} = tax_cur;
            pair_write{count,8} = number_car_between;
            count = count+1;
            pair_write{count,1} = carID_nxt;
            pair_write{count,2} = time_nxt;
            pair_write{count,3} = camID_nxt;
            pair_write{count,4} = make_nxt;
            pair_write{count,5} = model_nxt;
            pair_write{count,6} = color_nxt;
            pair_write{count,7} = tax_nxt;
            count = count+1;
        <span class="keyword">end</span>
        convoyMap(key_tmp) = pair_write;
        clear <span class="string">pair_write</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>

clear <span class="string">keySet</span>;
clear <span class="string">key_tmp</span>;
clear <span class="string">id</span>;
clear <span class="string">j</span>;
</pre><p>Further filtering convoy results to eliminate repeated and mis-match convoy results.</p><pre class="codeinput">keySet = keys(convoyMap);
<span class="keyword">for</span> i = 1:length(keySet)
    globalMap = containers.Map(<span class="string">'KeyType'</span>,<span class="string">'char'</span>,<span class="string">'ValueType'</span>,<span class="string">'any'</span>);
    reads = convoyMap(keySet{i});
    [len,~] = size(reads);
    count = 1;
    <span class="keyword">for</span> j = 1:2:len
        camID_cur = reads{j,3};
        camID_nxt = reads{j+1,3};
        time_cur = reads{j,2};
        time_nxt = reads{j+1,2};
        cur_stamp = [camID_cur <span class="string">' '</span> num2str(time_cur)];
        nxt_stamp = [camID_nxt <span class="string">' '</span> num2str(time_nxt)];
        <span class="keyword">if</span> ~isKey(globalMap, cur_stamp) &amp;&amp; ~isKey(globalMap, nxt_stamp)
            globalMap(cur_stamp) = 1;
            globalMap(nxt_stamp) = 1;
            new_reads(count,:) = reads(j,:);
            count = count+1;
            new_reads(count,:) = reads(j+1,:);
            count = count+1;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    [len,~] = size(new_reads);
    <span class="keyword">if</span> len&gt;threshold_pair*2
        convoyMap(keySet{i}) = new_reads;
    <span class="keyword">else</span>
        remove(convoyMap, keySet{i});
    <span class="keyword">end</span>
    clear <span class="string">new_reads</span>;
<span class="keyword">end</span>

tmpMap = containers.Map(<span class="string">'KeyType'</span>,<span class="string">'char'</span>,<span class="string">'ValueType'</span>,<span class="string">'any'</span>);
keySet = keys(convoyMap);
<span class="keyword">for</span> i=1:length(keySet)
    key = keySet{i};
    flag = strfind(key, <span class="string">' '</span>);
    vrm1 = key(1:flag(1)-1);
    vrm2 = key(flag(1)+1:end);
    reverseKey = [vrm2 <span class="string">' '</span> vrm1];
    <span class="keyword">if</span> ~isKey(tmpMap, key)&amp;&amp; ~isKey(tmpMap, reverseKey)
        tmpMap(key) = convoyMap(key);
    <span class="keyword">end</span>
    clear <span class="string">vrm1</span>;
    clear <span class="string">vrm2</span>;
<span class="keyword">end</span>
clear <span class="string">convoyMap</span>;
convoyMap = tmpMap;
</pre><p>Organise convoy results to include some statistic information in terms of lane difference, time difference between each two vehicles, and number of intervening vehicle between two vehicles, status of changing order, and duration of each convoy session.</p><pre class="codeinput">keySet = keys(convoyMap);
<span class="keyword">for</span> i=1:length(keySet)
    key = keySet{i};
    temp = convoyMap(key);
    convoys = temp(:,1:7);
    number_vehicles_between = temp(:,8);
    [height,width]=size(convoys);
    convoy_stats = zeros(height/2,5);
    <span class="comment">% initilise some variables</span>
    ct_change_order = 0;
    ct_time_difference = 0;
    ct_change_lane = 0;
    time_st = convoys{1,2};
    time_ed = convoys{height-1,2};
    time_span = time_ed - time_st;
    time_st_2 = convoys{2,2};
    time_difference = time_st_2 - time_st;
    <span class="keyword">if</span> time_difference&gt;0
        flag_delta_t = 0;
    <span class="keyword">else</span>
        flag_delta_t = 1;
    <span class="keyword">end</span>
    camIdMap = containers.Map(<span class="string">'KeyType'</span>,<span class="string">'char'</span>,<span class="string">'ValueType'</span>,<span class="string">'any'</span>);
    <span class="comment">% retrieve lane information</span>
    <span class="keyword">for</span> m=1:height
        camId = convoys{m,3};
        laneNum = getLaneNumber(anprMap, camId);
        convoys{m,width+1} = laneNum;
    <span class="keyword">end</span>
    <span class="comment">% generate raw feature of the convoy</span>
    ct=1;
    <span class="keyword">for</span> m=1:2:height-1
        laneNum1 = convoys{m,width+1};
        laneNum2 = convoys{m+1,width+1};
        <span class="comment">% record lane difference</span>
        laneDiff = laneNum1-laneNum2;
        convoy_stats(ct,1) = laneDiff;
        camId_1 = convoys{m,3};
        <span class="keyword">if</span> ~isKey(camIdMap, camId_1)
            camIdMap(camId_1) = 1;
        <span class="keyword">else</span>
            num = camIdMap(camId_1);
            camIdMap(camId_1) = num+1;
        <span class="keyword">end</span>
        time_1 = convoys{m,2};
        time_2 = convoys{m+1,2};
        camId_2 = convoys{m+1,3};
        deltaT = time_2 - time_1;
        <span class="comment">% record time difference between two vehicles</span>
        convoy_stats(ct,2) = deltaT;
        <span class="keyword">if</span> abs(deltaT)&lt;=20
            ct_time_difference = ct_time_difference+1;
        <span class="comment">% record number of times two vehicles changes order</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> flag_delta_t==0
            <span class="keyword">if</span> deltaT&lt;0
                ct_change_order = ct_change_order+1;
                flag_delta_t = 1;
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            <span class="keyword">if</span> deltaT&gt;0
                ct_change_order = ct_change_order+1;
                flag_delta_t = 0;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="comment">% record number of times two vehicles change lane.</span>
        <span class="keyword">if</span> ~strcmp(camId_1, camId_2)
            ct_change_lane = ct_change_lane+1;
        <span class="keyword">end</span>
        convoy_stats(ct,3) = number_vehicles_between{m,1};
        ct=ct+1;
    <span class="keyword">end</span>

    <span class="keyword">for</span> n=1:2:height-1
        realtime1 = convoys{n,2};
        realtime2 = convoys{n+1,2};
        <span class="keyword">if</span> realtime1&gt;realtime2
            tmp1 = convoys(n,:);
            tmp2 = convoys(n+1,:);
            convoys(n,:) = tmp2;
            convoys(n+1,:) = tmp1;
            clear <span class="string">tmp1</span>;
            clear <span class="string">tmp2</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    convoy_stats(1,4) = ct_time_difference;
    convoy_stats(2,4) = ct_change_order;
    convoy_stats(3,4) = ct_change_lane;
    convoy_stats(4,4) = time_span;
    convoy_stats(5,4) = length(camIdMap);

    <span class="keyword">for</span> n=1:(height/2)
        tmp = n*2;
        convoys{tmp-1,width+2} = convoy_stats(n,3);
        convoys{tmp-1,width+3} = convoy_stats(n,1);
        convoys{tmp-1,width+4} = abs(convoy_stats(n,2));
    <span class="keyword">end</span>
    convoyMap(key) = {convoys,convoy_stats};
<span class="keyword">end</span>
</pre><h2>Navigation<a name="6"></a></h2><div><ul><li>Back to <a href="..\html\main.html">Convoy Analysis Tool</a></li><li>Go to <a href="http://www.surrey.ac.uk/cs/research/msf/projects/polarbear_pattern_of_life_anpr_behaviour_extraction_analysis_and_recognition.htm">Project page</a></li></ul></div><h2>Author<a name="7"></a></h2><pre>Haiyue Yuan, 01.2016, Depatment of Computer Science, University of Surrey</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Refining Convoy Results
%  This function is to refine convoy results and reformat to a uniform format.

%%
%% I/O
% * INPUT:
%
% <html>
% <table border=2>
% <tr><td><b>pairMap</b></td><td>convoy results stored in a hash map structure.</td></tr>
% <tr><td><b>threshold_pair</b></td><td>this is the threshold of convoy session size.</td></tr>
% </table>
% </html>
%
% * OUTPUT:
%
% <html>
% <table border=2>
% <tr><td><b>convoyMap</b></td><td>refined convoy results saved in a hashmap. </td></tr>
% </table>
% </html>
%
%% Code
function convoyMap =  refineConvoy(pairMap, threshold_pair, anprMap)
%% 
% Filtering convoy results and organise it into a human-readable format.
keySet = keys(pairMap);
convoyMap = containers.Map('KeyType','char','ValueType','any');
for id=1:length(keySet)
    key_tmp = keySet{id};
    val = pairMap(key_tmp);
    if length(val)>threshold_pair
        tmp = strfind(key_tmp, ' ');
        carID_cur = key_tmp(1:tmp-1);
        carID_nxt = key_tmp(tmp+1:end);
        test_pair = cell(length(val),3);
        for mi=1:length(val)
            time_cur = val{mi}{1};
            test_pair{mi,1} = time_cur;
            test_pair{mi,2} = mi;
        end
        test_pair = sortrows(test_pair,1);
        count =1;
        pair_write = cell(length(val),7);
        [tmp_len,~]=size(test_pair);
        for im = 1:tmp_len
            idx = test_pair{im,2};
            time_cur = val{idx}{1};
            camID_cur = val{idx}{2};
            make_cur = val{idx}{3};
            model_cur = val{idx}{4};
            color_cur = val{idx}{5};
            tax_cur = val{idx}{6};
            time_nxt = val{idx}{7};
            camID_nxt = val{idx}{8};
            make_nxt = val{idx}{9};
            model_nxt = val{idx}{10};
            color_nxt = val{idx}{11};
            tax_nxt = val{idx}{12};
            number_car_between = val{idx}{13};
            pair_write{count,1} = carID_cur;
            pair_write{count,2} = time_cur;
            pair_write{count,3} = camID_cur;
            pair_write{count,4} = make_cur;
            pair_write{count,5} = model_cur;
            pair_write{count,6} = color_cur;
            pair_write{count,7} = tax_cur;
            pair_write{count,8} = number_car_between;
            count = count+1;
            pair_write{count,1} = carID_nxt;
            pair_write{count,2} = time_nxt;
            pair_write{count,3} = camID_nxt;
            pair_write{count,4} = make_nxt;
            pair_write{count,5} = model_nxt;
            pair_write{count,6} = color_nxt;
            pair_write{count,7} = tax_nxt;
            count = count+1;
        end
        convoyMap(key_tmp) = pair_write;
        clear pair_write;
    end
end

clear keySet;
clear key_tmp;
clear id;
clear j;
%%
% Further filtering convoy results to eliminate repeated and mis-match
% convoy results.
keySet = keys(convoyMap);
for i = 1:length(keySet)
    globalMap = containers.Map('KeyType','char','ValueType','any');
    reads = convoyMap(keySet{i});
    [len,~] = size(reads);
    count = 1;
    for j = 1:2:len
        camID_cur = reads{j,3};
        camID_nxt = reads{j+1,3};
        time_cur = reads{j,2};
        time_nxt = reads{j+1,2};
        cur_stamp = [camID_cur ' ' num2str(time_cur)];
        nxt_stamp = [camID_nxt ' ' num2str(time_nxt)];
        if ~isKey(globalMap, cur_stamp) && ~isKey(globalMap, nxt_stamp)
            globalMap(cur_stamp) = 1;
            globalMap(nxt_stamp) = 1;
            new_reads(count,:) = reads(j,:);
            count = count+1;
            new_reads(count,:) = reads(j+1,:);
            count = count+1;
        end
    end
    [len,~] = size(new_reads);
    if len>threshold_pair*2
        convoyMap(keySet{i}) = new_reads;
    else
        remove(convoyMap, keySet{i});
    end
    clear new_reads;
end

tmpMap = containers.Map('KeyType','char','ValueType','any');
keySet = keys(convoyMap);
for i=1:length(keySet)
    key = keySet{i};
    flag = strfind(key, ' ');
    vrm1 = key(1:flag(1)-1);
    vrm2 = key(flag(1)+1:end);
    reverseKey = [vrm2 ' ' vrm1];
    if ~isKey(tmpMap, key)&& ~isKey(tmpMap, reverseKey)
        tmpMap(key) = convoyMap(key);        
    end
    clear vrm1;
    clear vrm2;
end
clear convoyMap;
convoyMap = tmpMap;
%%
% Organise convoy results to include some statistic information in terms of
% lane difference, time difference between each two vehicles, and number of
% intervening vehicle between two vehicles, status of changing order, and
% duration of each convoy session.
keySet = keys(convoyMap);
for i=1:length(keySet)
    key = keySet{i};
    temp = convoyMap(key);
    convoys = temp(:,1:7);
    number_vehicles_between = temp(:,8);
    [height,width]=size(convoys);    
    convoy_stats = zeros(height/2,5);
    % initilise some variables
    ct_change_order = 0;
    ct_time_difference = 0;
    ct_change_lane = 0;
    time_st = convoys{1,2};
    time_ed = convoys{height-1,2};
    time_span = time_ed - time_st;
    time_st_2 = convoys{2,2};
    time_difference = time_st_2 - time_st;    
    if time_difference>0
        flag_delta_t = 0;
    else
        flag_delta_t = 1;
    end
    camIdMap = containers.Map('KeyType','char','ValueType','any');
    % retrieve lane information 
    for m=1:height
        camId = convoys{m,3};
        laneNum = getLaneNumber(anprMap, camId);
        convoys{m,width+1} = laneNum;
    end 
    % generate raw feature of the convoy
    ct=1;
    for m=1:2:height-1
        laneNum1 = convoys{m,width+1};
        laneNum2 = convoys{m+1,width+1};
        % record lane difference
        laneDiff = laneNum1-laneNum2;        
        convoy_stats(ct,1) = laneDiff; 
        camId_1 = convoys{m,3};
        if ~isKey(camIdMap, camId_1)
            camIdMap(camId_1) = 1;
        else
            num = camIdMap(camId_1);
            camIdMap(camId_1) = num+1;
        end
        time_1 = convoys{m,2};
        time_2 = convoys{m+1,2};
        camId_2 = convoys{m+1,3};        
        deltaT = time_2 - time_1;    
        % record time difference between two vehicles
        convoy_stats(ct,2) = deltaT; 
        if abs(deltaT)<=20
            ct_time_difference = ct_time_difference+1; 
        % record number of times two vehicles changes order
        end
        if flag_delta_t==0
            if deltaT<0
                ct_change_order = ct_change_order+1;
                flag_delta_t = 1;
            end
        else
            if deltaT>0
                ct_change_order = ct_change_order+1;
                flag_delta_t = 0;
            end
        end
        % record number of times two vehicles change lane.
        if ~strcmp(camId_1, camId_2)
            ct_change_lane = ct_change_lane+1;
        end       
        convoy_stats(ct,3) = number_vehicles_between{m,1}; 
        ct=ct+1;
    end
    
    for n=1:2:height-1
        realtime1 = convoys{n,2};
        realtime2 = convoys{n+1,2};
        if realtime1>realtime2
            tmp1 = convoys(n,:);
            tmp2 = convoys(n+1,:);
            convoys(n,:) = tmp2;
            convoys(n+1,:) = tmp1;
            clear tmp1;
            clear tmp2;
        end
    end    
    convoy_stats(1,4) = ct_time_difference;
    convoy_stats(2,4) = ct_change_order;
    convoy_stats(3,4) = ct_change_lane;
    convoy_stats(4,4) = time_span;
    convoy_stats(5,4) = length(camIdMap); 
    
    for n=1:(height/2)
        tmp = n*2;
        convoys{tmp-1,width+2} = convoy_stats(n,3);
        convoys{tmp-1,width+3} = convoy_stats(n,1);
        convoys{tmp-1,width+4} = abs(convoy_stats(n,2));
    end
    convoyMap(key) = {convoys,convoy_stats};
end


%% Navigation
% * Back to 
% <..\html\main.html Convoy Analysis Tool>
% * Go to
% <http://www.surrey.ac.uk/cs/research/msf/projects/polarbear_pattern_of_life_anpr_behaviour_extraction_analysis_and_recognition.htm Project page> 

%% Author
%  Haiyue Yuan, 01.2016, Depatment of Computer Science, University of Surrey
%%

##### SOURCE END #####
--></body></html>